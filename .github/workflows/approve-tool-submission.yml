name: Approve Tool Submission

on:
  issue_comment:
    types: [created]

permissions:
  contents: write
  issues: write
  actions: write

jobs:
  approve-tool:
    if: |
      github.event.issue.pull_request == null &&
      github.event.comment.body == '/approve' &&
      github.event.comment.user.login == 'ugurkocde' &&
      contains(github.event.issue.labels.*.name, 'tool-submission')

    runs-on: ubuntu-latest

    steps:
      - name: Create initial progress comment
        id: create_comment
        uses: actions/github-script@v7
        with:
          script: |
            const comment = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: '## Adding Your Tool\n\nProcessing your submission...\n\n| Step | Status |\n|:-----|:------:|\n| Validating submission | :hourglass_flowing_sand: |\n| Creating catalog entry | :white_circle: |\n| Saving to repository | :white_circle: |'
            });
            return comment.data.id;

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install OpenAI SDK
        run: npm install openai

      - name: Process tool submission
        id: process
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          COMMENT_ID: ${{ steps.create_comment.outputs.result }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const commentId = parseInt(process.env.COMMENT_ID);

            let toolName = '';

            async function updateProgress(step, status, error = null) {
              const steps = {
                validate: { label: 'Validating submission', order: 1 },
                create: { label: 'Creating catalog entry', order: 2 },
                save: { label: 'Saving to repository', order: 3 }
              };

              const getIcon = (stepKey) => {
                const stepOrder = steps[stepKey].order;
                const currentOrder = steps[step].order;
                if (status === 'error' && stepKey === step) return ':x:';
                if (stepOrder < currentOrder) return ':white_check_mark:';
                if (stepOrder === currentOrder) return ':hourglass_flowing_sand:';
                return ':white_circle:';
              };

              let body = '## Adding Your Tool\n\n';
              if (toolName) {
                body += 'Adding **' + toolName + '** to the catalog...\n\n';
              } else {
                body += 'Processing your submission...\n\n';
              }

              body += '| Step | Status |\n|:-----|:------:|\n';
              body += '| ' + steps.validate.label + ' | ' + getIcon('validate') + ' |\n';
              body += '| ' + steps.create.label + ' | ' + getIcon('create') + ' |\n';
              body += '| ' + steps.save.label + ' | ' + getIcon('save') + ' |';

              if (error) {
                body += '\n\n---\n\n:warning: **Error:** ' + error;
              }

              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId,
                body: body
              });
            }

            function toKebabCase(name) {
              return name.toLowerCase().replace(/[^\w\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            }

            function normalizeCategory(category) {
              const normalized = category.toLowerCase().trim();
              const valid = ['reporting', 'automation', 'packaging', 'troubleshooting', 'security', 'configuration', 'monitoring', 'migration', 'other'];
              return valid.includes(normalized) ? normalized : 'other';
            }

            function normalizeType(type) {
              const mapping = {
                'powershell module': 'powershell-module',
                'powershell script': 'powershell-script',
                'web app': 'web-app',
                'desktop app': 'desktop-app',
                'browser extension': 'browser-extension',
                'cli tool': 'cli-tool',
                'api wrapper': 'api-wrapper',
                'documentation': 'documentation',
                'other': 'other'
              };
              return mapping[type.toLowerCase().trim()] || 'other';
            }

            function isValidUrl(str) {
              try { new URL(str); return true; } catch { return false; }
            }

            async function fetchReadme(repoUrl) {
              const match = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
              if (!match) return null;
              const owner = match[1];
              const repo = match[2].replace(/\.git$/, '');
              for (const branch of ['main', 'master']) {
                for (const name of ['README.md', 'readme.md', 'Readme.md']) {
                  try {
                    const res = await fetch('https://raw.githubusercontent.com/' + owner + '/' + repo + '/' + branch + '/' + name);
                    if (res.ok) return await res.text();
                  } catch {}
                }
              }
              return null;
            }

            async function fetchWebsite(url) {
              try {
                const res = await fetch(url, { headers: { 'User-Agent': 'Mozilla/5.0 (compatible; AwesomeIntune/1.0)' } });
                if (res.ok) {
                  const html = await res.text();
                  return html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '').replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '').replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim().substring(0, 5000);
                }
              } catch {}
              return null;
            }

            async function enhanceWithAI(toolName, description, readme, website) {
              if (!process.env.OPENAI_API_KEY) {
                return { description: description, keywords: [] };
              }

              const OpenAI = require('openai');
              const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

              const parts = [];
              if (readme) parts.push('README:\n' + readme.substring(0, 10000));
              if (website) parts.push('Website:\n' + website);

              const ctx = parts.length > 0 ? parts.join('\n\n') : 'Description: ' + description;

              const prompt = 'Create a catalog entry for this Microsoft Intune tool.\n\n' +
                'Tool: ' + toolName + '\n\n' + ctx + '\n\n' +
                'Generate:\n' +
                '1. description: Professional 2-4 sentence description (max 500 chars) of what it does and key features\n' +
                '2. keywords: Array of 8 lowercase search keywords covering: category, features, technologies, use cases';

              try {
                const response = await openai.chat.completions.create({
                  model: 'gpt-5-nano',
                  response_format: { type: 'json_object' },
                  messages: [
                    { role: 'system', content: 'You are an expert at cataloging Microsoft Intune and endpoint management tools. Always respond with valid JSON.' },
                    { role: 'user', content: prompt + '\n\nRespond with JSON: {"description": "...", "keywords": ["...", "..."]}' }
                  ]
                });

                const content = response.choices[0]?.message?.content || '';
                return JSON.parse(content);
              } catch (e) {
                console.log('AI enhancement failed: ' + e.message);
              }
              return { description: description, keywords: [] };
            }

            // STEP 1: Validate submission
            await updateProgress('validate', 'working');

            const body = context.payload.issue.body;
            const fields = {};
            const fieldPattern = /- \*\*([^:*]+):\*\*\s*(.+?)(?=\n|$)/g;
            let match;
            while ((match = fieldPattern.exec(body)) !== null) {
              const label = match[1].trim().toLowerCase();
              const value = match[2].trim();
              const mapping = {
                'name': 'name', 'description': 'description', 'author': 'author',
                'repository url': 'repoUrl', 'category': 'category', 'type': 'type',
                'github': 'githubUrl', 'avatar': 'authorPicture', 'linkedin': 'linkedinUrl',
                'x/twitter': 'xUrl', 'website url': 'websiteUrl', 'download url': 'downloadUrl'
              };
              if (mapping[label] && value) fields[mapping[label]] = value;
            }

            const required = ['name', 'description', 'author', 'repoUrl', 'category', 'type'];
            const missing = required.filter(f => !fields[f]);
            if (missing.length > 0) {
              await updateProgress('validate', 'error', 'Missing required fields: ' + missing.join(', '));
              core.setOutput('success', 'false');
              return;
            }

            const urlFields = ['repoUrl', 'githubUrl', 'linkedinUrl', 'xUrl', 'websiteUrl', 'downloadUrl'];
            for (const f of urlFields) {
              if (fields[f] && !isValidUrl(fields[f])) {
                await updateProgress('validate', 'error', 'Invalid URL format for ' + f);
                core.setOutput('success', 'false');
                return;
              }
            }

            toolName = fields.name;
            const toolId = toKebabCase(fields.name);
            const toolPath = path.join('data', 'tools', toolId + '.json');

            if (fs.existsSync(toolPath)) {
              await updateProgress('validate', 'error', 'A tool with this name already exists');
              core.setOutput('success', 'false');
              return;
            }

            // STEP 2: Create catalog entry
            await updateProgress('create', 'working');

            const readmeContent = fields.repoUrl ? await fetchReadme(fields.repoUrl) : null;
            const websiteContent = fields.websiteUrl ? await fetchWebsite(fields.websiteUrl) : null;

            let enhancedDescription = fields.description;
            let keywords = [];
            if (process.env.OPENAI_API_KEY && (readmeContent || websiteContent)) {
              const enhanced = await enhanceWithAI(fields.name, fields.description, readmeContent, websiteContent);
              if (enhanced.description) enhancedDescription = enhanced.description;
              if (enhanced.keywords?.length > 0) keywords = enhanced.keywords;
            }

            const today = new Date().toISOString().split('T')[0];
            const toolJson = {
              id: toolId,
              name: fields.name,
              description: enhancedDescription,
              keywords: keywords,
              author: fields.author,
              authorPicture: fields.authorPicture || '',
              githubUrl: fields.githubUrl || '',
              linkedinUrl: fields.linkedinUrl || '',
              xUrl: fields.xUrl || '',
              repoUrl: fields.repoUrl,
              downloadUrl: fields.downloadUrl || '',
              websiteUrl: fields.websiteUrl || '',
              category: normalizeCategory(fields.category),
              type: normalizeType(fields.type),
              dateAdded: today
            };

            fs.writeFileSync(toolPath, JSON.stringify(toolJson, null, 2) + '\n');

            // STEP 3: Save to repository
            await updateProgress('save', 'working');

            core.setOutput('success', 'true');
            core.setOutput('tool_id', toolId);
            core.setOutput('tool_name', fields.name);
            core.setOutput('tool_path', toolPath);
            core.setOutput('description', enhancedDescription);

      - name: Commit and push tool JSON
        if: steps.process.outputs.success == 'true'
        id: commit
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add data/tools/
          git commit -m "Add tool: ${{ steps.process.outputs.tool_name }}"
          git push
          echo "committed=true" >> $GITHUB_OUTPUT

      - name: Final success update
        if: steps.process.outputs.success == 'true' && steps.commit.outputs.committed == 'true'
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ steps.create_comment.outputs.result }}
          TOOL_NAME: ${{ steps.process.outputs.tool_name }}
          TOOL_ID: ${{ steps.process.outputs.tool_id }}
          DESCRIPTION: ${{ steps.process.outputs.description }}
        with:
          script: |
            const commentId = parseInt(process.env.COMMENT_ID);
            const toolName = process.env.TOOL_NAME;
            const toolId = process.env.TOOL_ID;
            const description = process.env.DESCRIPTION;

            const body = [
              '## :white_check_mark: Tool Added Successfully!',
              '',
              '**' + toolName + '** has been added to the Awesome Intune catalog.',
              '',
              '| Step | Status |',
              '|:-----|:------:|',
              '| Validating submission | :white_check_mark: |',
              '| Creating catalog entry | :white_check_mark: |',
              '| Saving to repository | :white_check_mark: |',
              '',
              '---',
              '',
              '### About This Tool',
              '',
              '> ' + description,
              '',
              '---',
              '',
              ':camera: Screenshots will be captured automatically.',
              '',
              'Thank you for contributing to Awesome Intune!'
            ].join('\n');

            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: body
            });

      - name: Close issue and add label
        if: steps.process.outputs.success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['tool-added']
            });
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              state: 'closed'
            });
