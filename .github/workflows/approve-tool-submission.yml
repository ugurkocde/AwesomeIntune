name: Approve Tool Submission

on:
  issue_comment:
    types: [created]

permissions:
  contents: write
  issues: write
  actions: write

jobs:
  approve-tool:
    if: |
      github.event.issue.pull_request == null &&
      github.event.comment.body == '/approve' &&
      github.event.comment.user.login == 'ugurkocde' &&
      contains(github.event.issue.labels.*.name, 'tool-submission')

    runs-on: ubuntu-latest

    steps:
      - name: Create initial progress comment
        id: create_comment
        uses: actions/github-script@v7
        with:
          script: |
            const comment = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: '## Processing Tool Submission\n\n- [ ] Parsing issue body...\n- [ ] Fetching README from repository\n- [ ] Fetching website content\n- [ ] Enhancing with AI\n- [ ] Creating tool JSON file\n- [ ] Committing to repository\n- [ ] Triggering screenshot capture\n\n_Starting..._'
            });
            return comment.data.id;

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install OpenAI SDK
        run: npm install openai

      - name: Process tool submission
        id: process
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          COMMENT_ID: ${{ steps.create_comment.outputs.result }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const commentId = parseInt(process.env.COMMENT_ID);

            const stepState = {
              parse: { done: false, status: '' },
              readme: { done: false, status: '' },
              website: { done: false, status: '' },
              ai: { done: false, status: '' },
              json: { done: false, status: '' },
              commit: { done: false, status: '' },
              screenshot: { done: false, status: '' }
            };

            async function updateProgress(currentStep, message) {
              const getCheck = (key, current) => {
                if (stepState[key].done) return 'x';
                if (key === current) return '>';
                return ' ';
              };
              const body = [
                '## Processing Tool Submission',
                '',
                '- [' + getCheck('parse', currentStep) + '] Parsing issue body' + stepState.parse.status,
                '- [' + getCheck('readme', currentStep) + '] Fetching README from repository' + stepState.readme.status,
                '- [' + getCheck('website', currentStep) + '] Fetching website content' + stepState.website.status,
                '- [' + getCheck('ai', currentStep) + '] Enhancing with AI' + stepState.ai.status,
                '- [' + getCheck('json', currentStep) + '] Creating tool JSON file' + stepState.json.status,
                '- [' + getCheck('commit', currentStep) + '] Committing to repository' + stepState.commit.status,
                '- [' + getCheck('screenshot', currentStep) + '] Triggering screenshot capture' + stepState.screenshot.status,
                '',
                '_' + message + '_'
              ].join('\n');

              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId,
                body: body
              });
            }

            function toKebabCase(name) {
              return name.toLowerCase().replace(/[^\w\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
            }

            function normalizeCategory(category) {
              const normalized = category.toLowerCase().trim();
              const valid = ['reporting', 'automation', 'packaging', 'troubleshooting', 'security', 'configuration', 'monitoring', 'migration', 'other'];
              return valid.includes(normalized) ? normalized : 'other';
            }

            function normalizeType(type) {
              const mapping = {
                'powershell module': 'powershell-module',
                'powershell script': 'powershell-script',
                'web app': 'web-app',
                'desktop app': 'desktop-app',
                'browser extension': 'browser-extension',
                'cli tool': 'cli-tool',
                'api wrapper': 'api-wrapper',
                'documentation': 'documentation',
                'other': 'other'
              };
              return mapping[type.toLowerCase().trim()] || 'other';
            }

            function isValidUrl(str) {
              try { new URL(str); return true; } catch { return false; }
            }

            async function fetchReadme(repoUrl) {
              const match = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
              if (!match) return null;
              const owner = match[1];
              const repo = match[2].replace(/\.git$/, '');
              for (const branch of ['main', 'master']) {
                for (const name of ['README.md', 'readme.md', 'Readme.md']) {
                  try {
                    const res = await fetch('https://raw.githubusercontent.com/' + owner + '/' + repo + '/' + branch + '/' + name);
                    if (res.ok) return await res.text();
                  } catch {}
                }
              }
              return null;
            }

            async function fetchWebsite(url) {
              try {
                const res = await fetch(url, { headers: { 'User-Agent': 'Mozilla/5.0 (compatible; AwesomeIntune/1.0)' } });
                if (res.ok) {
                  const html = await res.text();
                  return html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '').replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '').replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim().substring(0, 5000);
                }
              } catch {}
              return null;
            }

            async function enhanceWithAI(toolName, description, readme, website) {
              const OpenAI = require('openai');
              const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
              const parts = [];
              if (readme) parts.push('README content:\n' + readme.substring(0, 8000));
              if (website) parts.push('Website content:\n' + website);
              const ctx = parts.length > 0 ? parts.join('\n\n---\n\n') : 'Submitted description: ' + description;

              const systemPrompt = 'You are helping catalog tools for Microsoft Intune administrators. Given information about a tool, generate: 1. A clear, professional description (2-4 sentences, max 500 characters) that explains what the tool does and its key features. 2. 6-10 relevant keywords for search/filtering (lowercase, 1-3 words each). Focus on Intune-specific functionality and benefits for IT administrators.';
              const userPrompt = 'Tool name: ' + toolName + '\n\n' + ctx + '\n\nRespond with ONLY a JSON object in this exact format:\n{"description": "Your improved description here", "keywords": ["keyword1", "keyword2", "keyword3"]}';

              try {
                const response = await openai.chat.completions.create({
                  model: 'gpt-5-nano',
                  max_completion_tokens: 1000,
                  messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userPrompt }
                  ]
                });
                const content = response.choices[0]?.message?.content || '';
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (jsonMatch) return JSON.parse(jsonMatch[0]);
              } catch (e) {
                console.log('AI enhancement failed: ' + e.message);
              }
              return { description: description, keywords: [] };
            }

            // STEP 1: Parse issue body
            await updateProgress('parse', 'Parsing issue body...');

            const body = context.payload.issue.body;
            const fields = {};
            const fieldPattern = /- \*\*([^:*]+):\*\*\s*(.+?)(?=\n|$)/g;
            let match;
            while ((match = fieldPattern.exec(body)) !== null) {
              const label = match[1].trim().toLowerCase();
              const value = match[2].trim();
              const mapping = {
                'name': 'name', 'description': 'description', 'author': 'author',
                'repository url': 'repoUrl', 'category': 'category', 'type': 'type',
                'github': 'githubUrl', 'avatar': 'authorPicture', 'linkedin': 'linkedinUrl',
                'x/twitter': 'xUrl', 'website url': 'websiteUrl', 'download url': 'downloadUrl'
              };
              if (mapping[label] && value) fields[mapping[label]] = value;
            }

            const required = ['name', 'description', 'author', 'repoUrl', 'category', 'type'];
            const missing = required.filter(f => !fields[f]);
            if (missing.length > 0) {
              stepState.parse.done = true;
              stepState.parse.status = ' - FAILED';
              await updateProgress('parse', 'Error: Missing required fields: ' + missing.join(', '));
              core.setOutput('success', 'false');
              core.setOutput('error', 'Missing required fields: ' + missing.join(', '));
              return;
            }

            const urlFields = ['repoUrl', 'githubUrl', 'linkedinUrl', 'xUrl', 'websiteUrl', 'downloadUrl'];
            for (const f of urlFields) {
              if (fields[f] && !isValidUrl(fields[f])) {
                stepState.parse.done = true;
                stepState.parse.status = ' - FAILED';
                await updateProgress('parse', 'Error: Invalid URL format for ' + f);
                core.setOutput('success', 'false');
                core.setOutput('error', 'Invalid URL: ' + fields[f]);
                return;
              }
            }

            const toolId = toKebabCase(fields.name);
            const toolPath = path.join('data', 'tools', toolId + '.json');
            if (fs.existsSync(toolPath)) {
              stepState.parse.done = true;
              stepState.parse.status = ' - FAILED';
              await updateProgress('parse', 'Error: Tool "' + toolId + '" already exists');
              core.setOutput('success', 'false');
              core.setOutput('error', 'Tool already exists: ' + toolId);
              return;
            }

            stepState.parse.done = true;
            stepState.parse.status = ' - Found: **' + fields.name + '**';
            await updateProgress('readme', 'Fetching README...');

            // STEP 2: Fetch README
            let readmeContent = null;
            if (fields.repoUrl) {
              readmeContent = await fetchReadme(fields.repoUrl);
              stepState.readme.done = true;
              stepState.readme.status = readmeContent ? ' - ' + readmeContent.length + ' chars' : ' - Not found';
            } else {
              stepState.readme.done = true;
              stepState.readme.status = ' - No repo URL';
            }
            await updateProgress('website', 'Fetching website...');

            // STEP 3: Fetch website
            let websiteContent = null;
            if (fields.websiteUrl) {
              websiteContent = await fetchWebsite(fields.websiteUrl);
              stepState.website.done = true;
              stepState.website.status = websiteContent ? ' - ' + websiteContent.length + ' chars' : ' - Could not fetch';
            } else {
              stepState.website.done = true;
              stepState.website.status = ' - No website URL';
            }
            await updateProgress('ai', 'Running AI enhancement...');

            // STEP 4: AI Enhancement
            let enhancedDescription = fields.description;
            let keywords = [];
            if (process.env.OPENAI_API_KEY && (readmeContent || websiteContent)) {
              const enhanced = await enhanceWithAI(fields.name, fields.description, readmeContent, websiteContent);
              if (enhanced.description) enhancedDescription = enhanced.description;
              if (enhanced.keywords && enhanced.keywords.length > 0) keywords = enhanced.keywords;
              stepState.ai.done = true;
              stepState.ai.status = ' - Generated ' + keywords.length + ' keywords';
            } else {
              stepState.ai.done = true;
              stepState.ai.status = ' - Skipped';
            }
            await updateProgress('json', 'Creating JSON file...');

            // STEP 5: Create JSON file
            const today = new Date().toISOString().split('T')[0];
            const toolJson = {
              id: toolId,
              name: fields.name,
              description: enhancedDescription,
              keywords: keywords,
              author: fields.author,
              authorPicture: fields.authorPicture || '',
              githubUrl: fields.githubUrl || '',
              linkedinUrl: fields.linkedinUrl || '',
              xUrl: fields.xUrl || '',
              repoUrl: fields.repoUrl,
              downloadUrl: fields.downloadUrl || '',
              websiteUrl: fields.websiteUrl || '',
              category: normalizeCategory(fields.category),
              type: normalizeType(fields.type),
              dateAdded: today
            };

            fs.writeFileSync(toolPath, JSON.stringify(toolJson, null, 2) + '\n');
            stepState.json.done = true;
            stepState.json.status = ' - ' + toolId + '.json';
            await updateProgress('commit', 'Committing to repository...');

            core.setOutput('success', 'true');
            core.setOutput('tool_id', toolId);
            core.setOutput('tool_name', fields.name);
            core.setOutput('tool_path', toolPath);
            core.setOutput('keywords_count', String(keywords.length));
            core.setOutput('description', enhancedDescription);

      - name: Commit and push tool JSON
        if: steps.process.outputs.success == 'true'
        id: commit
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add data/tools/
          git commit -m "Add tool: ${{ steps.process.outputs.tool_name }}"
          git push
          echo "committed=true" >> $GITHUB_OUTPUT

      - name: Update progress after commit
        if: steps.process.outputs.success == 'true' && steps.commit.outputs.committed == 'true'
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ steps.create_comment.outputs.result }}
          TOOL_NAME: ${{ steps.process.outputs.tool_name }}
          TOOL_ID: ${{ steps.process.outputs.tool_id }}
          KEYWORDS_COUNT: ${{ steps.process.outputs.keywords_count }}
        with:
          script: |
            const commentId = parseInt(process.env.COMMENT_ID);
            const body = [
              '## Processing Tool Submission',
              '',
              '- [x] Parsing issue body - Found: **' + process.env.TOOL_NAME + '**',
              '- [x] Fetching README from repository',
              '- [x] Fetching website content',
              '- [x] Enhancing with AI - Generated ' + process.env.KEYWORDS_COUNT + ' keywords',
              '- [x] Creating tool JSON file - ' + process.env.TOOL_ID + '.json',
              '- [x] Committing to repository',
              '- [>] Triggering screenshot capture...',
              '',
              '_Almost done..._'
            ].join('\n');
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: body
            });

      - name: Trigger screenshot workflow
        if: steps.process.outputs.success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'capture-screenshots.yml',
              ref: 'main'
            });

      - name: Final success update
        if: steps.process.outputs.success == 'true'
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ steps.create_comment.outputs.result }}
          TOOL_NAME: ${{ steps.process.outputs.tool_name }}
          TOOL_ID: ${{ steps.process.outputs.tool_id }}
          KEYWORDS_COUNT: ${{ steps.process.outputs.keywords_count }}
          DESCRIPTION: ${{ steps.process.outputs.description }}
        with:
          script: |
            const commentId = parseInt(process.env.COMMENT_ID);
            const toolName = process.env.TOOL_NAME;
            const toolId = process.env.TOOL_ID;
            const keywordsCount = process.env.KEYWORDS_COUNT;
            const description = process.env.DESCRIPTION;
            const body = [
              '## Tool Added Successfully!',
              '',
              '- [x] Parsing issue body - Found: **' + toolName + '**',
              '- [x] Fetching README from repository',
              '- [x] Fetching website content',
              '- [x] Enhancing with AI - Generated ' + keywordsCount + ' keywords',
              '- [x] Creating tool JSON file - ' + toolId + '.json',
              '- [x] Committing to repository',
              '- [x] Triggering screenshot capture',
              '',
              '---',
              '',
              '### Tool Details',
              '',
              '**Name:** ' + toolName,
              '**ID:** `' + toolId + '`',
              '**File:** `data/tools/' + toolId + '.json`',
              '',
              '**Description:**',
              '> ' + description,
              '',
              '---',
              '',
              'The screenshot capture workflow has been triggered. Screenshots will be added automatically.',
              '',
              'Thank you for your contribution!'
            ].join('\n');
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: body
            });

      - name: Close issue and add label
        if: steps.process.outputs.success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['tool-added']
            });
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              state: 'closed'
            });
